## Java三大特性

**封装**

利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

优点:

- 减少耦合: 可以独立地开发、测试、优化、使用、理解和修改
- 减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
- 有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能
- 提高软件的可重用性
- 降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的

**继承**

从一个已知的类中派生出一个新的类，新类可以拥有已知类的行为和属性，并且可以通过覆盖/重写来增强已知类的能力。

**多态**

多态分为编译时多态和运行时多态：

- 编译时多态主要指方法的重载
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

运行时多态有三个条件:

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

## Java基础知识

### 基本数据类型

> 基本数据类型被创建时，在栈内存中会被划分出一定的内存，并将数值存储在该内存中。

| 数据类型 | 分类         | 长度       | 数值范围                          | 默认值         | 包装类    | 缓存池数据范围 |
| -------- | ------------ | ---------- | --------------------------------- | -------------- | --------- | -------------- |
| boolean  | 布尔型       | 1位        | false/true                        | false          | Boolean   | false和true    |
| char     | 字符型       | 2字节/16位 | '\u0000'（0）到 '\uffff'（65535） | \u0000（空格） | Character | \u0000到\u007F |
| byte     | 字节型       | 1字节/8位  | -2^7（-128）到2^7-1（127）        | 0              | Byte      | 所有字符       |
| short    | 短整型       | 2字节/16位 | -2^15（-32768）到2^15-1（32767）  | 0              | Short     | -128到127      |
| int      | 整型         | 4字节/32位 | -2^31到2^31-1                     | 0              | Integer   | -128到127      |
| long     | 长整型       | 8字节/64位 | -2^63到2^63-1                     | 0              | Long      |                |
| float    | 单精度浮点型 | 4字节/32位 | -2^128到2^128                     | 0.0f           | Float     |                |
| double   | 双精度浮点型 | 8字节/64位 | -2^1024到2^1024                   | 0.0d           | Double    |                |

Java基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱（转为包装类）与拆箱（转为基本类型）完成。

**缓存池**

> Java对于每一种基本数据类型都会创建一个缓存池，编译器会**在缓冲池范围内的基本类型**自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象；使用 `new Integer(x)`创建则不会使用缓冲池。

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b);//true

Integer c = 128;
Integer d = 128;
System.out.println(c == d);//false

Integer x = new Integer(127);
Integer y = new Integer(127);
System.out.println(x == y);    // false
```



### 引用数据类型

> 引用数据类型被创建时，首先会在栈内存中分配一块空间，然后在堆内存中也会分配一块具体的空间用来存储数据的具体信息，即hash值，然后由栈中引用指向堆中的对象地址。

Java中的类、接口和数组都是引用数据类型。



### String字符串

> String 内部使用字符数组实现，且 String 被声明为 final，不可以被继承，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。
>
> 当我们调用 String 类的任何方法（比如说 `trim()`、`substring()`、`toLowerCase()`）时，总会返回一个新的对象，而不影响之前的值。
>
> Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码。

**String不可变的优点**

1. **可以缓存 hash 值**

因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。

2. **String Pool 的需要**

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。

3. **安全性**

String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。

4. **线程安全**

String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

**String家族对比**

| 类型          | 可变   | 线程安全                     |
| ------------- | ------ | ---------------------------- |
| String        | 不可变 | 安全                         |
| StringBuilder | 可变   | 不安全                       |
| StringBuffer  | 可变   | 安全，使用 synchronized 同步 |

## 参考资料

[Java全栈知识体系](https://pdai.tech/md/java/basic/java-basic-lan-basic.html)

